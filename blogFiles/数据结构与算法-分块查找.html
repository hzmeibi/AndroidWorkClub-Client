<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>index</title>
<style>
html,body{ font-family: "SF UI Display", ".PingFang SC","PingFang SC", "Neue Haas Grotesk Text Pro", "Arial Nova", "Segoe UI", "Microsoft YaHei", "Microsoft JhengHei", "Helvetica Neue", "Source Han Sans SC", "Noto Sans CJK SC", "Source Han Sans CN", "Noto Sans SC", "Source Han Sans TC", "Noto Sans CJK TC", "Hiragino Sans GB", sans-serif;
  font-size: 16px;
  color:#222
  -webkit-text-size-adjust:none;  min-width: 200px;
  max-width: 760px;
  margin: 0 auto; padding: 1rem;
  line-height: 1.5rem;

}
h1,h2,h3,h4,h5,h6{font-family: "PT Sans","SF UI Display", ".PingFang SC","PingFang SC", "Neue Haas Grotesk Text Pro", "Arial Nova", "Segoe UI", "Microsoft YaHei", "Microsoft JhengHei", "Helvetica Neue", "Source Han Sans SC", "Noto Sans CJK SC", "Source Han Sans CN", "Noto Sans SC", "Source Han Sans TC", "Noto Sans CJK TC", "Hiragino Sans GB", sans-serif;
text-rendering:optimizelegibility;margin-bottom:1em;font-weight:bold; line-height: 1.8rem;

}
h1,h2{position:relative;padding-top:1rem;padding-bottom:0.2rem;margin-bottom:1rem;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAABCAYAAACsXeyTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQIHWNIS0sr/v//PwMMDzY+ADqMahlW4J91AAAAAElFTkSuQmCC') bottom left repeat-x;}
h2{padding-top:0.8rem;padding-bottom:0.2rem;}
h1{ font-size: 1.6rem;}
h2{ font-size: 1.4rem;}
h3{ font-size: 1.2rem;}
h4{ font-size: 1.1rem;}
h5{ font-size: 1.0rem;}
h6{ font-size: 0.9rem;}

table{border-collapse:collapse;border-spacing:0;
  margin-top: 0.8rem;
  margin-bottom: 1.4rem;
}
tr{  background-color: #fff;
  border-top: 1px solid #ccc;}
th,td{padding: 5px 14px;
  border: 1px solid #ddd;}

blockquote{font-style:italic;font-size:1.1em;line-height:1.5em;padding-left:1em; border-left:4px solid #D5D5D5;    margin-left: 0;
    margin-right: 0;
    margin-bottom: 1.5rem; }

a{color:#1863a1}

pre,code,p code,li code{font-family:Menlo,Monaco,"Andale Mono","lucida console","Courier New",monospace}

pre{-webkit-border-radius:0.4em;-moz-border-radius:0.4em;-ms-border-radius:0.4em;-o-border-radius:0.4em;border-radius:0.4em;border:1px solid #e7dec3;line-height:1.45em;font-size:0.9rem;margin-bottom:2.1em;padding:.8em 1em;color:#586e75;overflow:auto; background-color:#fdf6e3;}

p code,li code{display:inline-block;white-space:no-wrap;background:#fff;font-size:0.9rem;line-height:1.5em;color:#555;border:1px solid #ddd;-webkit-border-radius:0.4em;-moz-border-radius:0.4em;-ms-border-radius:0.4em;-o-border-radius:0.4em;border-radius:0.4em;padding:0 .3em;margin:-1px 4px;}
p pre code,li pre code{font-size:1em !important;background:none;border:none}

img{max-width:100%;-webkit-border-radius:0.3em;-moz-border-radius:0.3em;-ms-border-radius:0.3em;-o-border-radius:0.3em;border-radius:0.3em;-webkit-box-shadow:rgba(0,0,0,0.15) 0 1px 4px;-moz-box-shadow:rgba(0,0,0,0.15) 0 1px 4px;box-shadow:rgba(0,0,0,0.15) 0 1px 4px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;border:#fff 0.5em solid}


hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}


/*

Orginal Style from ethanschoonover.com/solarized (c) Jeremy Hull <sourdrums@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #fdf6e3;
  color: #657b83;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-doctype,
.hljs-pi,
.lisp .hljs-string {
  color: #93a1a1;
}

/* Solarized Green */
.hljs-keyword,
.hljs-winutils,
.method,
.hljs-addition,
.css .hljs-tag,
.hljs-request,
.hljs-status,
.nginx .hljs-title {
  color: #859900;
}

/* Solarized Cyan */
.hljs-number,
.hljs-command,
.hljs-string,
.hljs-tag .hljs-value,
.hljs-rule .hljs-value,
.hljs-doctag,
.tex .hljs-formula,
.hljs-regexp,
.hljs-hexcolor,
.hljs-link_url {
  color: #2aa198;
}

/* Solarized Blue */
.hljs-title,
.hljs-localvars,
.hljs-chunk,
.hljs-decorator,
.hljs-built_in,
.hljs-identifier,
.vhdl .hljs-literal,
.hljs-id,
.css .hljs-function,
.hljs-name {
  color: #268bd2;
}

/* Solarized Yellow */
.hljs-attribute,
.hljs-variable,
.lisp .hljs-body,
.smalltalk .hljs-number,
.hljs-constant,
.hljs-class .hljs-title,
.hljs-parent,
.hljs-type,
.hljs-link_reference {
  color: #b58900;
}

/* Solarized Orange */
.hljs-preprocessor,
.hljs-preprocessor .hljs-keyword,
.hljs-pragma,
.hljs-shebang,
.hljs-symbol,
.hljs-symbol .hljs-string,
.diff .hljs-change,
.hljs-special,
.hljs-attr_selector,
.hljs-subst,
.hljs-cdata,
.css .hljs-pseudo,
.hljs-header {
  color: #cb4b16;
}

/* Solarized Red */
.hljs-deletion,
.hljs-important {
  color: #dc322f;
}

/* Solarized Violet */
.hljs-link_label {
  color: #6c71c4;
}

.tex .hljs-formula {
  background: #eee8d5;
}


</style>

<style> @media print{ .hljs{overflow: visible; word-wrap: break-word !important;} }</style></head><body><div class="markdown-body">
<h1 id="toc_0">数据结构与算法-分块查找</h1>

<pre><code>作者:Milo
日期:2018/06/20
描述:学习分块查找的分治思想。
来源:[Android 技术分享](https://www.androidwork.club/)
</code></pre>

<h1 id="toc_1">概念</h1>

<p>分块查找是折半查找和顺序查找的一种改进方法。分块查找只要求索引表是有序的，对块内节点没有排序要求，适用于节点动态变化的情况。也是采用<strong>分治思想</strong>。</p>

<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1505813980953&amp;di=4368be2511adac1160a67c46d9a884c0&amp;imgtype=0&amp;src=http://www.gzyz.net.cn/JxYd/UploadFiles_2742/200509/20050910215944171.gif" alt=""/></p>

<h2 id="toc_2">原理</h2>

<ol>
<li>对待查询的序列分成若干块，找出最大值或者最小值代表该子块的索引，形成索引表。并且记录最大值或者最小值在原始序列的位置索引。</li>
<li>使用顺序查找或者二分查找在索引表中找出满足条件的子块索引，然后使用顺序查询再将需要查询的元素与该子块进行匹配，直到查到为止。</li>
</ol>

<p><strong>IndexBlock</strong></p>

<pre><code>public static class IndexBlock {
        private int key;
        private int lastIndex;
        private int firstIndex;

        public IndexBlock(int key, int firstIndex,int lastIndex,) {
            this.key = key;
            this.lastIndex = lastIndex;
            this.firstIndex = firstIndex;
        }

        public int getKey() {
            return key;
        }

        public void setKey(int key) {
            this.key = key;
        }

        public int getLastIndex() {
            return lastIndex;
        }

        public void setLastIndex(int lastIndex) {
            this.lastIndex = lastIndex;
        }

        public int getFirstIndex() {
            return firstIndex;
        }

        public void setFirstIndex(int firstIndex) {
            this.firstIndex = firstIndex;
        }
    }

</code></pre>

<p><strong>BlockSearch</strong></p>

<pre><code>
 /**
     * 分块查找
     * 1.分块 建立索引表 保存第一个和最后一个的下表
     * 2.根据索引表查询所在的字块，之后遍历字块查询位置。
     */
    public static void BlockSearch(){
        int array[] = {0, 1, 2, 3, 4, 5, 6, 100, 200};
        int key = 100;
        //构建索引表 包含最大值和索引下标
        IndexBlock indexBlock1 = new IndexBlock(3, 0, 3);
        IndexBlock indexBlock2 = new IndexBlock(6, 4, 6);
        IndexBlock indexBlock3 = new IndexBlock(200, 7, 8);
        IndexBlock[] indexBlocks = {indexBlock1, indexBlock2, indexBlock3};
        int index = -1;//记录查询元素所在索引表的下表
        //使用顺序查询  也可以采用二分查找
        for (int i = 0; i &lt; indexBlocks.length; i++) {
            IndexBlock indexBlock = indexBlocks[i];
            if (indexBlock.getKey() == key) {
                index = i;
                break;
            } else if (indexBlock.getKey() &lt; key &amp;&amp; indexBlocks[i + 1].getKey() &gt; key) {
                index = i+1;
                break;
            } else if (indexBlock.getKey() &gt; key &amp;&amp; i == 0) {
                index = 0;
                break;
            } else if (indexBlock.getKey() &gt; key &amp;&amp; indexBlocks[i - 1].getKey() &lt; key &amp;&amp; i &gt; 0) {
                index = i-1;
                break;
            }
        }
        System.out.println(&quot;查找: &quot; + key + &quot;在索引表的位置为：  &quot; + index);

        //去指定字块中查找元素
        for (int i = indexBlocks[index].getFirstIndex(); i &lt; indexBlocks[index].getLastIndex(); i++) {
            if (array[i] == key) {
                System.out.println(&quot;找到: &quot; + key + &quot;在array的位置为：  &quot; + i);
            }
        }
    }
</code></pre>

<p><strong>main</strong></p>

<pre><code>    public static void main(String[] arg) {
        BlockSearch();
    }
</code></pre>

<p>输出结果为：</p>

<pre><code>查找: 100在索引表的位置为：  2
找到: 100在array的位置为：  7

</code></pre>

<h2 id="toc_3">参考</h2>

<p><a href="https://baike.baidu.com/item/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/9762617?fr=aladdin">1.百度百科</a></p>

<br><br><br><br>

</div></body>

</html>
